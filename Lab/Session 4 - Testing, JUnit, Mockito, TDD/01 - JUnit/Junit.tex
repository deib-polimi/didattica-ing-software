\documentclass{article}

\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage[usenames,dvipsnames]{color} % Required for custom colors
\usepackage{graphicx} % Required to insert images
\usepackage{listings} % Required for insertion of code
\usepackage{courier} % Required for the courier font
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template
\usepackage{hyperref}
% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}
\lhead{\hmwkAuthorName} % Top left header
\chead{\hmwkClass\ (\hmwkClassInstructor\ \hmwkClassTime): \hmwkTitle} % Top center head
\rhead{\firstxmark} % Top right header
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

\setlength\parindent{0pt} % Removes all indentation from paragraphs

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true
  tabsize=3
}

%----------------------------------------------------------------------------------------
%	DOCUMENT STRUCTURE COMMANDS
%	Skip this unless you know what you're doing
%----------------------------------------------------------------------------------------

% Header and footer for when a page split occurs within a problem environment
\newcommand{\enterProblemHeader}[1]{
\nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
}

% Header and footer for when a page split occurs between problem environments
\newcommand{\exitProblemHeader}[1]{
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1}{}\nobreak
}




%----------------------------------------------------------------------------------------
%	NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------

\newcommand{\hmwkTitle}{Junit} % Assignment title
\newcommand{\hmwkDueDate}{Martedi,\ Aprile 15,\ 2014} % Due date
\newcommand{\hmwkClass}{Ingegneria del Software 1} % Course/class
\newcommand{\hmwkClassTime}{} % Class/lecture time
\newcommand{\hmwkClassInstructor}{} % Teacher/lecturer
\newcommand{\hmwkAuthorName}{} % Your name

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
\vspace{2in}
\textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
\normalsize\vspace{0.1in}\small{Due\ on\ \hmwkDueDate}\\
\vspace{0.1in}\large{\textit{\hmwkClassInstructor\ \hmwkClassTime}}
\vspace{3in}
}

\author{\textbf{\hmwkAuthorName}}
\date{} % Insert date here if you want it to appear below your name

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle

%----------------------------------------------------------------------------------------
%	TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

%\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsections listed in the ToC

\newpage
\tableofcontents
\newpage



%----------------------------------------------------------------------------------------
\section{Preliminaries}
\subsection{Test di unit\`a}
Consentono di testare una singola entit\`a (classe o metodo). 
\subsection{JUnit}
JUnit \`e un framework per il test di unita per il linguaggio Java e consente di seguire un paradigma di programmazione test-driven.

\subsection{Unit test case}
\begin{itemize}
\item porzione di codice che assicura che un altra parte di codice (in genere un metodo) funziona come aspettato.
\item un test formale ben scritto \`e caratterizzato da un input noto e un output atteso che \`e stabilito prima dell'esecuzione del test.
\item in genere per ogni requisito (funzionalit\`a implementate) devono esserci \textbf{almeno} due test. Uno positivo e l'altro negativo
\item junit consente di utilizzare le annotazioni per identificare i metodi di test.
\item le asserzioni servono a confrontare i risultati ottenuti con quelli attesi
\end{itemize}

\subsection{Caratteristiche di JUnit}
JUnit fornisce le seguenti features:
\begin{itemize}
\item \emph{Fixture}: \`e possibile settare uno stato predefinito degli oggetti prima di eseguire un test. L'obbiettivo \`e di assicurare che l'ambiente nel quale i test sono eseguiti \`e noto e fissato in modo che i test siano ripetibili (@Before (setting), @After (pulizia)). 
\item \emph{Test runner}: \`e utilizzato per eseguire i test (trasparente all'utente)
\end{itemize}




\section{Problem}
Vogliamo creare un metodo che converte dollari in franchi svizzeri (CHF).

\textbf{Requisito base}.
Dobbiamo essere capaci di moltiplicare un numero per un altro. 
Esempio se il cambio Dollari-CHF 2 :1, 5 Dollari vengono convertiti in 10 franchi.

\begin{itemize}
\item Visto che siamo test driven partiamo dai test e non dagli oggetti
\item File $>$ new $>$ Junit Test Case (Test)
\item scegliamo il nome del test TestMultiplication. Nota il nome del test deve iniziare con la parola \textbf{Test} e deve essere chiara la funzionalit\`a testata
\end{itemize}
\section{Step 1}
\subsection{Step 1.1 Creating the test}

\begin{lstlisting}
package org.ingsoft.junit;

import static org.junit.Assert.*;

import org.ingsoft.junit.tdd.Dollar;
import org.junit.Test;

public class TestMultiplication {
	@Test
	public void test() {
		Dollar five=new Dollar(5);
		five.times(2);
		assertEquals(10, five.amount);
	}
}
\end{lstlisting}

Problemi: public fields, side effects, integer for monetary amounts.

Vogliamo compilare il prima possibile. Cosa dobbiamo fare?
\begin{itemize}
\item Creare la classe dollaro
\item Creare un costruttore
\item Creare il metodo times
\item Creare l'attributo pubblico  amount
\end{itemize}

\subsection {Step 1.2 Making the test running}
\begin{lstlisting}
package org.ingsoft.junit.tdd;
public class Dollar {
	
	public int amount=0;
	
	public Dollar(int value){
		
	}
	public void times(int value){
		
	}
}
\end{lstlisting}
Compila perfetto. Problema il test non \`e passato.

\begin{lstlisting}
package org.ingsoft.junit.tdd;
public class Dollar {
	
	public int amount=10;
	
	public Dollar(int value){
		
	}
	public void times(int value){
		
	}
}
\end{lstlisting}
Compila perfetto il test \`e passato.

\subsection {Step 1.3 Refactor}
C'\`e una dipendenza tra il codice e il test. Ovvero abbiamo del codice duplicato (il numero 10). Come possiamo eliminarlo?
\begin{itemize}
\item Passo  1: nel metodo  times scriviamo this.amount = 5*2 
\item Passo 2: da dove possiamo ottenere il 5?  
\begin{itemize}
\item Mettiamo nel costruttore this.amount=value;
\item Mettiamo nella metodo times  this.amount = this.amount*2 
\end{itemize}
\item Passo 3: da dove possiamo ottenere il 2?
\begin{itemize}
\item mettiamo nel metodo times  this.amount = this.amount* value
\end{itemize}
\item Passo 4: rimuoviamo il codice replicato
\begin{itemize}
\item  replace amount = amount* value with amount *= value
\end{itemize}
\end{itemize}

\section{Step 2}
Problema dopo aver eseguito un operazione l'oggetto dollaro cambia.
\subsection{Step 2.1 Creating the test}
\begin{lstlisting}
package org.ingsoft.junit;

import static org.junit.Assert.*;

import org.ingsoft.junit.tdd.Dollar;
import org.junit.Test;

public class TestMultiplication {
	@Test
	public void test() {
		Dollar five=new Dollar(5);
		five.times(2);
		assertEquals(10, five.amount);
		five.times(3);
		assertEquals(15, five.amount);
	}
}
\end{lstlisting}


\subsection{Step 2.2 Making the test running}
Cambiare l'interfaccia della classe dollaro per fagli ritornare un nuovo oggetto.
\begin{lstlisting}
@Test
	public void test() {
		Dollar five=new Dollar(5);
		Dollar product=five.times(2);
		assertEquals(10, product.amount);
		product=five.times(3);
		assertEquals(15, product.amount);
	}
\end{lstlisting}

\begin{lstlisting}
package org.ingsoft.junit.tdd;

public class Dollar {
	
	public int amount;
	
	public Dollar(int value){
		this.amount=value;
	}
	public Dollar times(int value){
		this.amount *= value;
		return null;
	}
}
\end{lstlisting}


\begin{lstlisting}
public Dollar times(int value){
		return new Dollar(this.amount *= value);
	}
\end{lstlisting}



\subsection{Step 2.3 Refactor}
Posso mettere l'attributo amount come privato.


\section{Best Practices}
\begin{itemize}
\item non utilizzare il costruttore del test case per settare il test case.
\item non assumere di conoscere l'ordine nel quale i test case vengono eseguiti (anche all'interno del singolo junit).
\item non scrivere test cases che hanno side effects 
\item scrivere i test che leggono dati da locazioni del file sistem utilizzando path relativi
\item memorizzare i dati che sono necessari per i test assieme ai test stessi
\item assicurati che i nomi dei test sono time-indipendent
\item scegliere i nomi dei  test nel modo corretto
\begin{itemize}
\item il nome del test deve iniziare con la parola Test (esempio \emph{TestClassUnderTest})
\item il nome dei metodi nel test case devono descrivere cosa viene testato (esempio \emph{testLoggingEmptyMessage()})
\end{itemize}
\item utilizza i metodi assert e fail di junit nel modo corretto per mantenere il codice pulito. Considera per esempio la leggibilit\' a di assertEquals ("The number of credentials should be 3", 3, creds); rispetto a assert (creds == 3); 
\item commentare i test con la javadoc
\item mantieni i test piccoli e veloci
\end{itemize}

\section{Testing private methods}
Per testare dei metodi privati ci sono 2 strade possibili:
\begin{itemize}
\item testarlo attraverso un altro metodo pubblico che lo utilizza
\item utilizzare la \emph{reflection} (non consigliato! usa solo nel caso sia proprio necessario).
\end{itemize}
In pratica conviene testare solo la parte di codice visibile da un ipotetico “client” completamente esterno al codice, e quindi trascurare i metodi protetti

\section{Che cosa testare?}
Non \`e una regola assoluta, ma il principio generale \`e: \emph{quanto pi\`u una parte di codice \`e visibile dall'esterno, tanto pi\`u deve essere testata}

Unit tests should \textbf{not} test network, multithreading or GUI code.
The tests should be deterministic and automatic with predefined input
and the expected output, so also do not test code that interact with
standard input (System.in). In case you want to test such code you need to
\emph{mock} the interaction with standard input with code
that provides constant input (for example a constant string). 

Mocking can be done manually with the a common interface and the
Adapter pattern or using a mocking library (e.g., Mockito).

\section{Advanced Testing (optional)}

\subsection{Parametric testing}


Junit 4 has introduced a new feature Parameterized tests.Parameterized
tests allow developer to run the same test over and over again using
different values.
Parametrized testing is supported from the version 4 of JUnit, so
remember to create JUnit 4 tests and update the JUnit dependency in
your pom to version 4.12:

\begin{lstlisting}
<dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.12</version>
      <scope>test</scope>
</dependency>
\end{lstlisting}

Let's consider using parametric testing for a simple add function:

\begin{lstlisting}
public class MyClass {

	public int add(int a, int b){
		return a+b;
	}
	
}
\end{lstlisting}

Using the following test class:

\begin{lstlisting}
import static org.junit.Assert.*;
import java.util.Arrays;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;

@RunWith(value = Parameterized.class)
public class MyClassTest {

	private int numberA;
	private int numberB;
	private int expected;
	
	public MyClassTest(int numberA, int numberB, int expected) {
		this.numberA = numberA;
		this.numberB = numberB;
		this.expected = expected;
	}

	//Declares parameters here
	@Parameters(name = "{index}: add({0}+{1})={2}")
	public static Iterable<Object[]> data() {
		return Arrays.asList(new Object[][] { 
			{ 1, 1, 2 }, 
			{ 2, 2, 4 }, 
			{ 8, 2, 10 }, 
			{ 4, 5, 9 } 
		});
	}
	
	@Before
	public void setUp() throws Exception {
	}

	@Test
	public void test() {
		MyClass c = new MyClass();
		assertEquals(expected,c.add(numberA, numberB));
	}

}
\end{lstlisting}

To use the feature annotate test class with
@RunWith(value = Parameterized.class). Then, create a public static
method annotated with @Parameters that returns a collection of objects
(as Array) as test data set.

These data will be used to initialize the instance of the test class,
so you need to create a public constructor that takes in what is
equivalent to one "row" of test data.

Create a private variable to hold data for each "column" of your
input test data. 

Once this is set you can create your tests case(s) using the private
variables as the source of the test data.

For convenience you can pass parameters to the @Parameters annotation
that will define the formatting for your tests. This is useful to
figure out which particular "row'' of your input data has caused a
test failure. In the example, we use $"{index}: add({0}+{1})={2}"$
that simply prints index of the test followed by the input and
expected output. For example, if input parameters are  
“{ 8, 2, 10 }” from the example, then {0} = 8, {1} = 2, {2} = 10,
hence the formatting will show "2: add(8+2)=10"


\subsection{Static mocking}

When designing and implementing a larger piece of software you soon
realize that objects you instantiate encapsulate some functionality, but
delegate many other to different objects. For instance, you have controller
classes that depend on action classes and action that depend on data
classes and so on.

The idea of unit testing is that we want to test our code in
isolation, i.e., without testing the dependencies. This test allows
you to verify that the code being tested works, regardless of it's
dependencies. The approach is that you assume the dependencies work
according to their specification and then you write the code that
relies on the dependencies according to its own specification.
After that each module is tested in isolation.

To ensure the isolation one needs to "mock'' the dependencies with so
called mock object. They simulate the behavior of real objects in
controlled ways and decouple and localize your unit tests.

For instance, consider an extension of the previous class with code
that reads from standard input:


\begin{lstlisting}
public class MyClass {

	public int foo(){
                Scanner sc=new Scanner(System.in);
                int a = sc.nextInt();
                int b = sc.nextInt();
		sc.close();

                //do something to a and b to obtain c
                return c;
	}
	public static void main(String argv[]){
		MyClass c = new MyClass();
		c.foo();
	}	
}
\end{lstlisting}

Testing the method foo() cannot be done automatically due to the
dependency on the code that reads from standard input. So let's
refactor the code a bit.

\begin{lstlisting}
public interface Input {
	public int nextInt();
}

public class InputMock implements Input {

	@Override
	public int nextInt() {
		return 0;
	}

}

public class StandardInputProxy implements Input {

	Scanner sc=new Scanner(System.in);

	@Override
	public int nextInt() {
		return sc.nextInt();;		
	}

}
\end{lstlisting}

First we can create a common interface for original and mock objects
refactoring-in the methods that we need to use in foo().
Then we make a generic dependency on the interface in the original class.

\begin{lstlisting}
public class MyClass {

	Input sc;
	public MyClass(Input i) {
		sc=i;
	}

	public int foo(){
                int a = sc.nextInt();
                int b = sc.nextInt();
		
                //do something to a and b to obtain c
                return c;
	}
	public static void main(String argv[]){
		MyClass c = new MyClass(new StandardInputProxy());
		c.foo();
	}	
	
}
\end{lstlisting}

However, now we can "plug-in'' out mock object at the test phase:

\begin{lstlisting}
public class MyClassTest extends TestCase {

	MyClass c;
	protected void setUp() throws Exception {
		super.setUp();
		c =  new MyClass(new InputMock());
	}
	
	public void testExample()
        {
		int x = c.foo();
		assertEquals(0, x);
        }
}
\end{lstlisting}


The example shows a very simple mock object, however you can implement
arbitrary test input generation logic in \texttt{InputMock}.

\subsection{Dynamic mocking (with Mockito)}

As we said before, unit test should test a class in isolation. Side
effects from other classes or the system should be eliminated if
possible. 
One way to resolve this is to introduce mock classes implementing
the proxy design pattern like shown above. However, this approach
pollutes your design with unnecessary classes used only for testing.

To solve this, you can generate mock object at runtime with the help
of the Mockito library. 

To use mockito add the following maven dependency:

\begin{lstlisting}
<dependency>
	<groupId>org.mockito</groupId>
	<artifactId>mockito-all</artifactId>
	<version>1.9.5</version>
</dependency>
\end{lstlisting}

Mockito supports the creation of mock objects with the static
mock() method. If you add a static import for org.mockito.Mockito.*, you can
access Mockito's methods like mock() directly. Static imports even allow
you to call static members, i.e., methods and fields of a class
directly without specifying the class. 

To configure which values are returned at a method call Mockito
defines a fluent API. You can use the verify() method to ensure that a
method was called. 

The when(....).thenReturn(....) call chain can be used to specify a
condition and a return value for this condition. If you specify more
than one value, they are returned in the order of specification until
the last one is used. Afterwards the last specified value is
returned. Mocks can also return different values depending on
arguments passed into a method. You also use methods like anyString or
anyInt to define that independent of the input value a certain return
value should be returned. 

The doReturn(...).when(...).methodCall call chain works similar but is
useful for void methods. The doThrow variant can be used for methods
which return void to throw an exception. 


All these usages are demonstrated by the following code snippet. 



\begin{lstlisting}

import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

@Test
public void test1()  {
  //  create mock
  MyClass test = Mockito.mock(MyClass.class);
  
  // define return value for method foo()
  when(test.foo()).thenReturn(42);
  
  // use mock in test.... 
  assertEquals(test.foo(), 42);
}

\end{lstlisting}

The example above creates a mock object for our MyClass and defines
that foo() returns 42.

\begin{lstlisting}

//...

// Demonstrates the return of multiple values
@Test
public void testMoreThanOneReturnValue()  {
  Iterator i= mock(Iterator.class);
  when(i.next()).thenReturn("Mockito").thenReturn("rocks");
  String result=i.next()+" "+i.next();
  //assert
  assertEquals("Mockito rocks", result);
}

// this test demonstrates how to return values based on the input
@Test
public void testReturnValueDependentOnMethodParameter()  {
  Comparable c= mock(Comparable.class);
  when(c.compareTo("Mockito")).thenReturn(1);
  when(c.compareTo("Eclipse")).thenReturn(2);
  //assert
  assertEquals(1,c.compareTo("Mockito"));
}

// this test demonstrates how to return values independent of the input value

@Test
public void testReturnValueInDependentOnMethodParameter()  {
  Comparable c= mock(Comparable.class);
  when(c.compareTo(anyInt())).thenReturn(-1);
  //assert
  assertEquals(-1 ,c.compareTo(9));
}

// return a value based on the type of the provide parameter

@Test
public void testReturnValueInDependentOnMethodParameter()  {
  Comparable c= mock(Comparable.class);
  when(c.compareTo(isA(Todo.class))).thenReturn(0);
  //assert
  Todo todo = new Todo(5);
  assertEquals(todo ,c.compareTo(new Todo(1)));
} 


// this test demonstrates how use doThrow

@Test(expected=IOException.class)
public void testForIOException() {
  // create an configure mock
  OutputStream mockStream = mock(OutputStream.class);
  doThrow(new IOException()).when(mockStream).close();
  
  // use mock
  OutputStreamWriter streamWriter= new OutputStreamWriter(mockStream);
  streamWriter.close();
} 

\end{lstlisting}





\end{document}



