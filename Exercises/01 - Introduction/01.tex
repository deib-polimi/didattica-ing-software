\documentclass{article}

\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage[usenames,dvipsnames]{color} % Required for custom colors
\usepackage{graphicx} % Required to insert images
\usepackage{listings} % Required for insertion of code
\usepackage{courier} % Required for the courier font
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template
\usepackage{hyperref}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{framed}
\usepackage{listings}
\usepackage{subfigure}
\usepackage{afterpage}
\usepackage{amsmath,amssymb}            
\usepackage{rotating}  
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage[scriptsize]{caption} 
\hyphenation{a-gen-tiz-za-zio-ne}
% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1} % Line spacing

\lstset{
  numbers=left,
  stepnumber=5,    
  firstnumber=1,
  numberfirstline=true
}

% Set up the header and footer
\pagestyle{fancy}
\lhead{\hmwkAuthorName} % Top left header
\chead{\hmwkClass\ (\hmwkClassInstructor\ \hmwkClassTime): \hmwkTitle} % Top center head
\rhead{\firstxmark} % Top right header
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

\setlength\parindent{0pt} % Removes all indentation from paragraphs

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true
  tabsize=3
}

%----------------------------------------------------------------------------------------
%	DOCUMENT STRUCTURE COMMANDS
%	Skip this unless you know what you're doing
%----------------------------------------------------------------------------------------

% Header and footer for when a page split occurs within a problem environment
\newcommand{\enterProblemHeader}[1]{
\nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
}

% Header and footer for when a page split occurs between problem environments
\newcommand{\exitProblemHeader}[1]{
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1}{}\nobreak
}



%----------------------------------------------------------------------------------------
%	NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------

\newcommand{\hmwkTitle}{01 - Introduzione} % Assignment title
\newcommand{\hmwkDueDate}{Martedi,\ Marzo 15,\ 2016} % Due date
\newcommand{\hmwkClass}{Ingegneria del Software 1} % Course/class
\newcommand{\hmwkClassTime}{} % Class/lecture time
\newcommand{\hmwkClassInstructor}{Claudio Menghi, Francesco Marconi, Alessandro Rizzi} % Teacher/lecturer
\newcommand{\hmwkAuthorName}{} % Your name

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
\vspace{2in}
\textmd{\textbf{\hmwkClass\\ \vspace{1cm} \hmwkTitle \vspace{1cm}}}\\
\normalsize\vspace{0.1in}\small{\hmwkDueDate}\\
\vspace{0.1in}\large{\textit{\hmwkClassInstructor\ \hmwkClassTime}}
\vspace{3in}
}


\theoremstyle{definition} 

\newtheorem{mydef}{Definizione}
\newtheorem{lemma}{Lemma}

\newtheorem{theorem}{Theorem}[section]

\author{\textbf{\hmwkAuthorName}}
\date{} % Insert date here if you want it to appear below your name

\input{../Commands.tex}
%----------------------------------------------------------------------------------------

\begin{document}

\maketitle

%----------------------------------------------------------------------------------------
%	TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

%\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsections listed in the ToC

\newpage
\tableofcontents
\newpage



%----------------------------------------------------------------------------------------
\section{Introduzione}
Questa lezione copre le  slides ``Classi come astrazioni" o in alternativa i capitoli  1, 2, 3, 4 e 5 del libro  Pellegrino Principe -- “Java 8”.


\subsection{Le caratteristiche di Java}
Questa esercitazione ha come scopo quella di fornire una panoramica su Java e sulle sue caratteristiche fondamentali. In particolare Java \`e:
\begin{itemize}
\item \emph{Portabile}: \`e la caratteristica principale di Java. L'obiettivo di Java \`e quello di consentire allo sviluppatore di  \emph{scrivere il programma una volta sola avendo la certezza che sar\`a possibile eseguirlo ovunque indipendentemenre dall'architettura della macchina su cui viene eseguito}. La filosofia di Java \`e quindi ``Write Once, Run Anywhere".
\item \emph{Compilato}: Java \`e un linguaggio compilato, ovvero viene ``tradotto" dal linguaggio di programmazione Java al linguaggio ``oggetto" bytecode. 
\item \emph{Orientato agli oggetti}: in un linguaggio orientato agli oggetti lo sviluppatore ragiona in termini di oggetti ovvero astrazioni dei concetti del mondo reale che lo sviluppatore vuole modellare\footnote{La filosofia \`e diversa da quella utilizzata, per esempio, quando si scrive in C, dove gli ingredienti fondamentali sono le procedure. Infatti in un linguaggio procedurale le componenti fondamentali sono le funzioni (``procedure") che manipolano i dati del programma.}. In realt\`a Java \`e un linguaggio multi-paradigma dal momento che \`e anche procedurale, e se consideriamo Java 8 \`e anche funzionale (parzialmente).
\item \emph{Staticamente tipizzato}: un linguaggio \`e staticamente tipizzato quando \`e necessario associare ad ogni variabile un tipo.
\end{itemize}

\subsubsection{Java \`e portabile e compilato}
La caratteristica principale di Java \`e il fatto di essere portabile/platform independent. 
Se prendiamo per esempio C il compilatore genera un linguaggio ``oggetto" che \`e dipendente dalla macchina nel quale il compilatore viene eseguito. 
Il codice compilato pu\`o \textbf{solo} essere eseguito sulla piattaforma per il quale il codice \`e stato compilato.

In Java la fase di compilazione produce un codice intermedio chiamato \emph{byte-code} che pu\`o essere eseguito su macchine differenti supposto che ci sia installato sulla macchina un \emph{interprete} (Java Virtual Machine JVM) capace di capire il byte-code. 
In altre parole il byte-code \`e un codice intermedio prodotto dopo la compilazione. Il Byte-code differisce dal codice eseguibile (per esempio dai file ``.exe") dal momento che deve essere interpretato da una  Java Virtual Machine per essere eseguito.

\begin{figure}[h]
\centering
    \includegraphics[width=0.7\textwidth]{Img/jvm-architecture.png}
    \caption{Java architecture}
    \label{JavaArchitecture}
\end{figure}

L'architettura del linguaggio Java \`e mostrata in Figura~\ref{JavaArchitecture}. Pi\`u precisamente:

\begin{itemize}
\item MyProgram.java: \`e il codice sorgente nativo dell'applicazione Java (Il file che contiene il nostro codice)
\item Compiler: (Compilatore) prende in input il nostro codice Java  (i nostri files \texttt{.java}), e produce dei file intermedi  (\texttt{.class}) ovvero i file contenenti il byte-code.
\item Java Virtual Machine (JVM): \`e l'interprete che deve essere installato sulla nostra macchina locale al fine di eseguire il byte-code. 
Il byte-code viene interpretato dalla Java Virtual Machine. Per questo motivo alcuni testi considerano Java anche come un linguaggio interpretato.
\end{itemize}

Per eseguire il vostro programma su una macchina \`e sufficiente che l'utente abbia installato 
%una macchina virtuale: 
la Java Virtual Machine. 
In particolare, il \textbf{Java Run-time Environment} (JRE) contiene la macchina virtuale che consente di eseguire i programmi Java.  
JREs differenti sono associati a sistemi operativi differenti. 
Una volta istallata la JRE \`e possibile eseguire i file \texttt{.class} generati.

Nota che, una volta generati, i file \texttt{.class} possono essere eseguiti su ogni sistema cha abbia una Macchina Virtuale Java installata, indipendentemente dal sistema operativo su cui la macchina virtuale \`e eseguita.

Per compilare i file \texttt{.java} \`e necessario avere un tool di sviluppo Java: un \textbf{Java Development Kit} (JDK). 
Il JDK include la JRE e contiene un set di tool di svilupo che constentono di scrivere e compilare i tuoi programmi Java.




\subsubsection{Java \`e orientato agli oggetti}
La programmazione orientata agli oggetti implica un approccio alla programmazione completamente diverso rispetto ai normali linguaggi procedurali. Gli oggetti sono entit\`a che hanno una ``vita propria" ed esistono indipendentemente dal come vengono utilizzate all'interno della nostra applicazione. 
%In altre parole un 

\begin{mydef} \textbf{Oggetto} \`e un astrazione di un oggetto del mondo reale e ne descrive le caratteristiche  che sono di interesse allo sviluppatore.
\end{mydef}

In altre parole in un paradigma orientato agli oggetti lo sviluppatore descrive il mondo e i suoi oggetti e come il mondo evolve nel corso del tempo. 
In un paradigma procedurale lo sviluppatore specifica \textbf{come} risolvere un problema, mentre in un linguaggio orientato agli oggetti lo sviluppatore prima descrive ``il problema" e poi cerca una strategia per risolvere il problema utilizzando il modello del mondo costruito.

Gli oggetti vengono creati partendo da modelli pi\`u generali chiamati classi. 

\begin{mydef} \textbf{Classi} sono dei \emph{tipi} definiti dall'utente che descrivono degli oggetti. In particolare descrivono l'oggetto, il suo \emph{stato} e come lo \emph{stato dell'oggetto} cambia in risposta a delle operazioni eseguite sull'oggetto.
\end{mydef}

Utilizzando un esempio automobilistico possiamo pensare alle classi come ai documenti di progetto di un autovettura, e agli oggetti come alle macchine realizzate partendo dai quei documenti. In altre parole le classi sono la teoria, gli oggetti sono particolari \textbf{istanze} di una specifica classe. 

Gli oggetti vengono creati col costrutto \textbf{new}. Per esempio l'istruzione seguente crea un nuovo oggetto di tipo \texttt{Bike}. 
\begin{lstlisting}
Bike myBike=new Bike();
\end{lstlisting}
La descrizione del tipo bike, ovvero la classe \texttt{Bike}, \`e presentata nel seguito.
\begin{lstlisting}[language=Java,escapechar=|]
public class Bike {

	public Bike(){
	}
}
\end{lstlisting}
Le classi sono definiti mediante la parola chiave (keyword) \texttt{class} e descrivono le caratteristiche dello stato di un oggetto e come lo stato pu\`o cambiare nel tempo.


\subsubsection{Java \`e staticamente tipizzato}
\begin{mydef} \textbf{Staticamente tipizzato} un linguaggio \`e staticamente tipizzato se ogni variabile \`e associata a un tipo: non \`e possibile creare una variabile senza un tipo.
\end{mydef}
\begin{lstlisting}
Bike bike1=new Bike();
\end{lstlisting}
Per esempio, l'istruzione precedente dichiara una variabile di tipo \texttt{Bike} con \textbf{identificatore} \texttt{bike1}, che \`e associata a un oggetto di classe \texttt{Bike}. 
In Java ogni variabile deve essere associata a un tipo.


\subsection{Variabili e tipi di riferimento}
Prima di discutere le variabili e i tipi di riferimento discutiamo per l'organizzazione della memoria in Java 

\begin{itemize}
\item \textbf{Stack} e \textbf{Heap}:  Lo stack e lo heap sono due aree di memoria che sono utilizzate per contenere le nostre variabili e i nostri oggetti.
\begin{itemize}
\item Lo \textbf{stack} \`e un area di memoria dove \`e possibile memorizzare informazioni. E' molto rapido e basato su un LIFO pattern.
\item Lo \textbf{heap} \`e uno spazio di memoria assegnabile al progetto e facilmente 
estendibile. 
\item Lo stack ha una dimensione fissa assegnata prima di eseguire il programma ``durante la fase di startup". Lo heap non viene utilizzato seguendo uno specifico pattern, e ci\`o lo rende molto flessibile (\`e estendibile) ma anche pi\`u lento. 
\end{itemize}


\begin{mydef} Una variabile \`e uno spazio di memoria che contiene un ``valore". 
\end{mydef}
Java \`e fortemente tipizzato (\emph{strongly typed}), quindi \emph{ogni variabile ha un tipo}. Il compilatore durante la compilazione controlla che le variabili siano utilizzate in maniera corretta in relazione al loro tipo.\\

\item \textbf{Variabili primitive}: le variabili primitive definiscono una ``cella di memoria" che contiene direttamente il valore della variabile. Le variabili primitive di Java sono:
\begin{itemize}
\item \emph{byte}: 8 bit, \emph{short}: 16 bit, \emph{int}: 32 bit, \emph{long}: 64 bit, \emph{float}: 32 bit, \emph{double}: 64 bit, \emph{char}: 16 bit \emph{boolean}: true/false
\end{itemize}
\item \textbf{Variabili riferimento}: le altre variabili contengono un riferimento alle aree di memoria cha contengono il ``valore": l'\textbf{oggetto}. I tipi di riferimento 1) possono essere definiti dall'utente mediante classi e interfacce, 2) includono gli array e le enumerazioni.
\item variabili primitive e di riferimento possono essere utilizzate nella stesso modo: come attributi, restituiti o passati a metodi.
\end{itemize}

Le \emph{variabili}:
\begin{itemize}
\item sono allocate sullo \emph{stack} a run-time quando si chiama il metodo su cui si sono dichiarate
\item si trovano nello heap quando rappresentano un attributo di un oggetto (vedremo in seguito).
\item se non sono attributi di un oggetto sono deallocate quando il sottoprogramma ritorna al chiamante
\end{itemize}
Gli \emph{oggetti}:
\begin{itemize}
\item sono allocati sullo heap.
\end{itemize} 



\textbf{Dove vengono allocati gli oggetti Java?}\\
Gli oggetti Java risiedono in una zona detta \emph{heap}. 
L'heap viene creato all'avvio della JVM e pu\'o cambiare dimensione durante l'esecuzione 
dell'applicazione. A discrezione della JVM viene eseguita l'operazione di ``\emph{garbage collection}'', che consiste nella rimozione degli oggetti non pi\`u utilizzabili dal programma per fare posto ad altri. 
Il componente che effettua tale operazione prende il nome di ``\emph{garbage collector}''.

\vspace{1cm}

\textbf{Quali sono le differenze tra i puntatori di C e le veriabili di riferimento di Java?}
\begin{itemize}
\item un riferimento non pu\`o essere de-allocato dall'utente, viene rimosso dal garbage collector
\item un riferimento non permette l'acceso all'indirizzo di memoria relativo ad un oggetto%TODO, ma a but a value that represent it
\item non \`e possibile effettuare operazioni aritmetiche sul riferimento, come \`e possibile sui puntatori nel linguaggio C
\end{itemize}







\subsubsection{Dichiarazione di una variabile}
Per dichiarare una variabile \`e sufficiente specificare il \emph{tipo} e un \emph{identificatore}, ovvero un nome simbolico utilizzato per riferirsi alla variabile\footnote{Java \`e case sensitive quindi caratteri in upper e lower case sono interpretati come caratteri differenti.}. \\
Per esempio, l'istruzione:
\begin{lstlisting}[language=Java,escapechar=|]
int number;
\end{lstlisting}
dichiara una variabile di tipo primitivo ``\texttt{int}" con identificatore ``\texttt{number}", mentre l'istruzione
\begin{lstlisting}[language=Java,escapechar=|]
Car mycar;
\end{lstlisting}
dichiara una variabile di tipo riferimento ``\texttt{Car}" e con identificatore ``\texttt{mycar}".
La dichiarazione non alloca spazio per l'oggetto ma solo per il riferimento all'oggetto. \\

\emph{Qual \`e la differenza tra tipi riferimenti e puntatori (e.g., i puntatori di C)?}\\
Ci sono varie differenze e similitudini tra riferimenti e puntatori. In genere un riferimento pu\`o essere interpretato come un puntatore ``ad alto livello", mentre la differenza fondamentale \`e  il fatto che \emph{nei riferimenti l'indirizzo di memoria non \`e noto e non interessa}. Per questo motivo, ad esempio, i riferimenti non consentono l'utilizzo dell'aritmetica dei puntatori. 


\subsubsection{Convenzione di notazione}
In Java i nomi di classi, variabili e metodi fanno uso della notazione a cammello (\emph{CamelCase}).
La notazione a cammello \`e costituita dalla giustapposizione delle parole che costituiscono l'identificativo, unite con l'iniziale di ogni parola maiuscola. 
La prima lettera dell'identificativo è maiuscola nel caso di classi e minuscola nel caso di metodi e attributi/variabili. 

\subsubsection{Inizializzazione di una variabile}
Una variabile non pu\`o essere usata senza essere inizializzata. Quando un attributo viene dichiarato gli viene assegnato un valore di default.

Il riferimento \`e assegnato inizialmente il valore \texttt{null}, per indicare che il riferimento non \`e ancora associato a un oggetto.
Le variabili vengono inizializzate tramite l'operatore ``$=$''. Questo operatore assegna un valore ad una variabile.
Il tipo della variabile deve essere compatibile col tipo del valore.\\
Dichiarazione e inizializzazione possono essere effettuate in una o  pi\`u istruzioni, a discrezione
del programmatore.
\begin{lstlisting}[language=Java,escapechar=|]
// This characters are used to start a command
// declares the variable
int number;
// initializes a variable
number=0
\end{lstlisting}
Nell'esempio precedente la dichiarazione e l'assegnamento della variabile \texttt{number} sono
effettuati in istruzioni differenti.
\begin{lstlisting}[language=Java,escapechar=|]
// This characters are used to start a command
// declares and initializes the variable
int number=0
\end{lstlisting}
In quest'ultimo esempio nella medesima istruzione \texttt{number} viene dichiarata e inizializzata.

\subsubsection{Creazione di un nuovo oggetto}
La creazione di un nuovo oggetto si effettua con l'operatore new. Il metodo new costruisce un nuovo oggetto del tipo specificato e ritorna il suo riferimento
\begin{lstlisting}[language=Java,escapechar=|]
Car auto=new Car();
\end{lstlisting}
Effettuando new Car() viene creato un nuovo oggetto di tipo auto e viene ritornato il corrispettivo reference, che nel caso specifico viene assegnato alla variabile di riferimento auto mediante l'operatore di assegnamento $=$.

\subsection{Costruttori}
\begin{mydef} \textbf{Costruttore} un costruttore \`e un metodo della classe che ha il \emph{suo stesso nome} e \emph{non} ha tipi o valori di ritorno. Lo scopo del costruttore \`e quello di creare un nuovo ogggetto relativo a una classe.
\end{mydef}

\begin{itemize}
\item se in una classe non viene definito un costruttore ne viene automaticamente generato ed utilizzato uno di default senza argomenti che, all'atto della creazione dell'oggetto, richiama il costruttore di default senza argomenti della super classe.
\item se per\`o vengono creati dei costruttori il costruttore di default non risulta pi\`u disponibile a meno che definito dall'utente. 
\item l'uso di costruttori diversi permette di creare un tipo di oggetto passando argomenti diversi 
\end{itemize}

Un costruttore alloca e inizializza
\begin{itemize}
\item alloca lo spazio per gli attributi di tipo \emph{primitivo}
\item alloca lo spazio per i \emph{riferimenti} agli attributi definiti dall'utente
\item inizializza i riferimenti e gli attibuti. Se un riferimento non \`e inizializzato gli viene associato il valore null. Se una variabile numerica non \`e inizializzata gli viene associato il valore zero. Ai \texttt{boolean} viene assegnato il valore false
\end{itemize}


\subsection{Array}
\begin{itemize}
\item Un array \`e una variabile di tipo reference: contiene un reference a un area di memoria dove ci sono un insime di variabili dello stesso tipo.
\item un array ha una natura \emph{statica}: esso mantiene la propria dimensione, ovvero il numero di elementi che contiene.
\end{itemize}

Vari tipi di array possono essere dichiarati:
\begin{itemize}
\item array monodimensionali (anche noti come vettori)
\begin{itemize}
\item possono essere dichiarati come \texttt{type nomeVariabile[]} o come \texttt{type[] nomeVariabile} dove \texttt{type} indica il tipo di dato contenuti negli elementi dell'array mentre le parentesi poste dopo l'identificatore o dopo il tipo indicano che la variabile \`e di tipo array.
\item ovviamente in mancanza di \emph{inizializzazione} la dichiarazione di un array non alloca spazio per gli elementi dell'array
\item l'allocazione si realizza come \texttt{int[] i=new int[10];} dove 10 \'e il numero di elementi dell'array
\end{itemize}
\item Per quanto riguarda gli array multidimensionali la dichiarazione e l'inizializzazione avviene in maniera analoga \texttt{float[][] f=new float[10][10];}
\end{itemize}

\subsection{Semantic versioning}
Solitamente, ogni applicazione \`e associata a pi\`u versioni. Il numero di versione tiene traccia di come l'applicazione evolve nel tempo.
Per esempio Java 1.8 \`e una evoluzione di Java 1.7.

Solitamente a una applicazione \`e associato un numero di versione nella forma MAJOR.MINOR.PATCH, dove i campi hanno il seguente significato:
\begin{itemize}
\item MAJOR ogni volta che viene rilasciata una nuova versione con un cambiamento MAJOR significa che un cambiamento nelle API che rende l'applicazione incompatibile con la versione precedente \`e stata rilasciata. 
\item MINOR viene modificato ogni volta che vengono rilasciate nuove funzionalit\`a in una maniera backward compatibile
\item PATCH viene eseguita un attivit\`a di bug fixing in maniera backward compatibile.
\end{itemize}

Regole per l'uso di semantic versioning:
\begin{itemize}
\item il software DEVE dichiarare delle API pubbliche, precise e comprensibili;
\item MAJOR, MINOR e PATCH devono essere dei numeri NON negativi, e devono sempre incrementare, con la seguente eccezione: quando la versione MAJOR (MINOR) viene incrementata il valore di MINOR e PATCH (PATCH) viene settato a zero;
\item una volta che una verione \`e rilasciata il contenuto della versione NON pu\`o essere modificato
\item la versione 0.y.z \`e la versione iniziale del software. In questa versione le API pubbliche devono essere considerate non stabili. Tutto pu\`o cambiare nel tempo.
\item la versione 1.0.0 \`e la prima versione del software che definisce le API pubbliche, da questo momento l'applicazione dipende dalle API pubbliche
\item il valore di PATCH deve essere incrementato solo se backward compatible e bug fixes sono eseguiti. (Il bug fix corregge un comportamento scorretto)
\item il valore di MINOR deve essere incrementato se sono aggiunte funzionalit\'a introdotte nelle API pubbliche o se sono rimosse funzionalit\`a deprecate. Dopo aver incrementato MINOR \`e necessario settare PATCH a zero
\item il valore di MAJOR deve essere incrementato quando cambiamenti incompatibili sono introdotti nelle API pubbliche. PATCH e MINOR devono essere resettati a zero
\item una pre-release viene indicata utilizando un trattino seguita da un identificatore che specifica la patch version. Per esempio, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92. 
\end{itemize}

La versione iniziale del software \`e in genere la 0.1.0. Da li si inizia a utilizzare le regole sopra descritte.
\`E tempo di passare alla versione 1.0.0 quando:
\begin{itemize}
\item il software viene utilizzato in produzione;
\item si hanno delle API stabili che possono essere usati da altri.
\end{itemize}


Il lettore interessato pu\`o trovare informazioni addizionali in \url{http://semver.org/}.

\subsection{Java versions history}
\begin{table}[h]
\center
\begin{tabular}{ | p{1cm} | p{12cm} |}
\hline
JDK & improvements \\
\hline
JDK1.1 & RMI, inner classes \\
JDK1.2 & Swing, Collections \\
JDK1.3 & CORBA, JNDI \\
JDK1.4 & Regular expressions, logging, assert  \\
JDK1.5 & Generics, Autoboxing, Unboxing, Enumerations, cuncurrency utilities  \\
JDK1.6 & JDBC, GUI, compiler optimization IO \\
JDK1.7 & String switch, type inference improvements, new IO libraries, new network protocols, and cryptography algorithms  \\
JDK1.8 & lambda expressions,  map-reduce, annotations, static library linking with JNI\\
\hline
\end{tabular}

\end{table}

\section{Esercizi}
L'obiettivo di questi esercizi \`e di chiarire le caratteristiche di Java prima descritte.

\subsection{Java \`e compilato ed \`e portabile}
Questi esercizi hanno come fine quello di mostrare il fatto che Java \`e un linguaggio compilato ed \`e portabile. 

\subsubsection{Esercizio}
\Esercizio{Scrivere un programma Java che stampa a video: ``Benvenuto al corso di Ingegneria del Software"}

\begin{itemize}
\item \textbf{Creare un file Java}
\begin{itemize}
\item Aprire  TextEdit (per gli utenti mac), Blocco Note (per gli utenti Windows) of vi (per gli utenti Linux) .
\item (Per gli utenti Mac da TextEdit selezionare \textit{preferenze} $>$ \textit{Solo Testo} $>$ \textit{File} $>$ \textit{New} )
\item Scrivere il codice  Java seguente
\end{itemize}
\end{itemize}
\lstinputlisting{Source/Esercizio1/Welcome.java}
\begin{itemize}
\item \textbf{Descrizione del file creato}
\begin{itemize}
\item il codice definisce una classe (\texttt{class}) chiamata  \texttt{Welcome} con un singolo metodo  chiamato \texttt{main}
\item \texttt{public} \`e utilizzato per specificare che la classe \`e pubblica: \`e possibile accedervi dall'esterno, per esempio da altre classi.
\item la classe ha solo un metodo statico main
\item \texttt{void} specifica che il metodo non ritorna alcun valore
\item \texttt{static} specifica che il metodo \`e statico: pu\`o essere invocato senza instanziare l'oggetto di classe  (Welcome)
\item \texttt{main} \`e il ``metodo di partenza" che deve essere presente in almeno una classe affinch\`e l'applicazione sia eseguibile. 
\item \texttt{args} contiene il parametro (anche chiamato argomento) del metodo main. Il parametro \texttt{args} contiene i valori dei parametri passati al metodo main quando il programma \`e eseguito da command line.
\item \texttt{String[]} (array of String) \`e il tipo della variabile args 
\item \texttt{System.out.println} scrive il testo specificato sullo schermo.
\end{itemize}
\end{itemize}
\begin{itemize}
\item \textbf{Salvare il file} con nome \texttt{Welcome.java} (attenzione: non scegliere un nome differente e controllare che l'estensione del file sia .java).
\end{itemize}

\begin{itemize}
\item \textbf{Compilare il file Java}:
\begin{itemize}
\item aprire il Terminale (per gli utenti Mac e Linux) o il Prompt dei Comandi (per gli utenti Windows)
\item portarsi nella cartella dove si trova il file creato mediante i seguenti comandi
\begin{itemize}
\item per aprire una sottocartella e tornare alla cartella padre \`e possibile utilizzare i  comandi \emph{cd}, e \emph{cd ..}, rispettivamente. Per mostrare il contenuto della cartella utilizzare  il comando \emph{ls} (\texttt{dir} per gli utenti Windows).
\end{itemize}
\item Digitare \texttt{javac Welcome.java}
\item il comando \texttt{javac}  \textbf{compila} il file \texttt{Welcome.java} file e genera un file .class (o un jar) che contiene il bytecode file che \`e possibile eseguire su qualunque piattaforma\footnote{Ricordiamo che il bytecode \`e una rappresentazione intermedia che pu\`o essere interpretata da una macchina virtuale Virtual Machine.}. Questo processo supporta la  \textbf{portabilit\`a}. 
\item \emph{Per eseguire con successo il comando \emph{javac} \`e necessario avere una JDK (Java Development Kit) istallata sul proprio pc\footnote{Nota che la JDK include anche il Java Run-Time Environment}.} La JDK permette quindi di  \emph{compilare} e \emph{eseguire} il programma creato.
\end{itemize}
\end{itemize}

\begin{itemize}
\item \textbf{Eseguire il file Java}
\begin{itemize}
\item il java bytecode (.class) pu\`o essere eseguito in qualsiasi architettura dove \`e installata una Virtual Machine (la quale fornisce un  \textbf{interprete} per il $Java$ bytecode) . In particolare la Java JRE fornisce questa Virtual Machine.
\item per eseguire il file bytecodefile eseguire il comando \texttt{java Welcome}
\item questo comando esegue il   \texttt{main} method della classe \texttt{Welcome}
\end{itemize}
\end{itemize}




\subsubsection{Esercizio}
\Esercizio{Richiedere all'utente di inserire il proprio nome (per esempio Carlo) e stampare ``Ciao Carlo, Benvenuto al corso di Ingegneria del Software"}

\begin{itemize}
\item \textbf{Creare un file Java}
\begin{itemize}
\item crea un file Java con nome \texttt{Welcome}
\item scrivere il seguente codice Java
\end{itemize}
\end{itemize}

\lstinputlisting{Source/Esercizio2/Welcome.java}
\begin{itemize}
\item \textbf{Descrizione del file creato}
\begin{itemize}
\item \texttt{import} \`e utilizzata per importare la classe \texttt{Scanner} contenuta all'interno del package \texttt{java.util}
\item \texttt{new} crea (\texttt{instantiate}) un nuovo oggetto di classe \texttt{Scanner}
\item \texttt{scanner.nextLine()} legge la prossima riga inserita
\item \texttt{scanner.close()} chiude lo scanner
\end{itemize}
\end{itemize}

\begin{itemize}
\item  \textbf{Compilare ed eseguire il file creato}
\begin{itemize}
\item \texttt{javac Welcome.java}
\item \texttt{java Welcome}
\end{itemize}
\end{itemize}

\subsection{Java \`e orientato agli oggetti e staticamente tipizzato}
Questa sezione presenta un insieme di esercizi che mostrano che Java \`e orientato agli oggetti e staticamente tipizzato.


\subsubsection{Esercizio}
\Esercizio{Modellizzare in Java una bicicletta, una bicicletta (in un particolare istante temporale) ha una determinata velocit\`a, che dipende dalla marcia inserita e dal ritmo di pedalata}

Per progettare le vostre classi in Java \`e necessario rispondere a due quesiti:
\begin{itemize}
\item Come \`e possibile descrivere lo \emph{stato} degli oggetti relativi a una determinata classe?
\item Quali sono le \emph{funzionalit\`a} che gli oggetti di una determinata classe devono fornire?
\end{itemize}

\lstinputlisting{Source/Esercizio3/Bike.java}



\subsubsection{Esercizio}
\Esercizio{Implementare un client per la classe bicicletta}

Un Java si utilizza l'espressione client per indicare una generica classe, che utilizza la classe da noi progettata (nel nostro caso la classe Bicicletta). 

\lstinputlisting{Source/Esercizio3/Client.java}

\begin{itemize}
\item compilare ed eseguire il programma
\end{itemize}

\begin{itemize}
\item 
\textbf{Quesiti:}\\
\begin{itemize}
\item Qual \`e lo stato dell'oggetto dopo l'istruzione \texttt{Bike bike1;}?\\
\emph{l'oggetto non ha uno stato, visto che non esiste esiste solamente il suo reference.}
\item Qual \`e lo stato dell'oggetto  \texttt{bike1} dopo l'istruzione  \texttt{bike1 = new Bike()}?\\
 \texttt{gear=1}, \texttt{cadence=0}, \texttt{speed=0}
\item Qual \`e lo stato dell'oggetto  \texttt{bike1} dopo l'istruzione \texttt{bike2 = new Bike()}?\\
 \texttt{gear=1}, \texttt{cadence=0}, \texttt{speed=0}
\item Qual \`e lo stato dell'oggetto  \texttt{bike1} dopo l'istruzione \texttt{bike2 = new Bike()}?\\
 \texttt{gear=1}, \texttt{cadence=0}, \texttt{speed=0}
\end{itemize}
\end{itemize}



\subsubsection{Esercizio}
\Esercizio{Dire che cosa viene stampato quando viene eseguita la seguente classe}

\lstinputlisting{Source/Esercizio4/Client.java}


\begin{itemize}
\item Che cosa stampa l'istruzione  \texttt{bike1==bike2}?\\
 \emph{false, visto che i references ai due oggetti  \texttt{bike1} e \texttt{bike2} si riferiscono a due oggetti diversi}
\end{itemize}


\subsubsection{Esercizio}
\Esercizio{Aggiungere alla bicicletta una funzionalit\`a che permette all'oggetto di stampare il suo stato}

\lstinputlisting{Source/Esercizio5/Bike.java}

\subsubsection{Esercizio}
\Esercizio{Mettere la classe Bike nel package transport}

\begin{itemize}
\item creare la cartella transport \texttt{mkdir transport}
\end{itemize}
\lstinputlisting{Source/Esercizio6/transport/Bike.java}

\subsection{Esercizio}
\Esercizio{Modificare il client affinche' chiami il metodo \texttt{printState()}}

\lstinputlisting{Source/Esercizio6/Client.java}

Se cambiamo la cartella della classe \texttt{bike} dobbiamo cambiarne anche il package.

\subsection{Eclipse Integrated Development Environment}
La gestione di un progetto man mano che la complessit\`a aumenta diventa sempre pi\`u difficile. Per questo, nello sviluppo softeware  Integrated Development Environment ($IDE$) sono comunemente utilizzati. Gli $IDE$s rimuovono alcune delle difficolt\`a solitamente incontrate nel processo di sviluppo e forniscono funzionalit\`a aggiuntive come il completamento automatico del codice. In questo corso e in paricolare nel laboratorio useremo $Eclipse$ $IDE$ come ambiente di sviluppo\footnote{$Netbeans$ \`e uno dei maggiori competitor di $Eclipse$}.  

\subsubsection{Esercizio}
\Esercizio{Crea il tuo primo progetto in Eclipse}

\begin{itemize}
\item \textbf{Creare un progetto in eclipse}
\begin{itemize}
\item apri $Eclipse$
\item non appena $Eclipse$ si avvia richiede all'utente di selezionare il $Workspace$. Il $Workspace$ \`e l'area di lavoro dell'utente, contiene i file creati etc. L'utente pu\`o definire vari $Workspace$s ognuno dei quali pu\`o contenere pi\`u progetti.
\item clicca su $Workbench$ 
\item \texttt{File} $>$ \texttt{New} $>$ \texttt{Project} $>$ \texttt{Maven Project}
\item seleziona \texttt{Create a simple project}
\item digita \texttt{IngegneriaDelSoftware1} come Group Id e \texttt{Esercitazione1} come Artifact Id
\item scegli \texttt{finish}
\item Quando create il vostro nuovo progetto Maven\footnote{Maven sar\`a spiegato nel corso del laboratorio.} in Eclipse, Eclipse crea automaticamente la struttura del vostro progetto. In particolare, 
\begin{itemize}
\item $src/main/java$ contiene il codice sorgente Java dell'applicazione in via di sviluppo.
\item $src/main/resources$ contiene le ``risorse" utilizzate dalla vostra applicazione, file di configurazione, etc\ldots
\item $src/test/java$ contiene le classi usate per testare la vostra applicazione
\item $src/test/resources$ contiene le risorse necessarie a testare la vostra applicazione
\end{itemize}
\end{itemize}
\end{itemize}



\begin{itemize}
\item \textbf{Creare un package}
\begin{itemize}
\item tasto destro su \texttt{src/main/java} $>$ New $>$ package 
\item scegliere il nome del package ($exercizio10$)
\item premere finish
\end{itemize}
\end{itemize}

\begin{itemize}
\item \textbf{Creare una nuova classe in Eclipse}
\begin{itemize}
\item tasto destro sul package dove si desidera creare la classe  $>$ New $>$ class 
\item scegliere il nome della classe (\texttt{Bike})
\item scegliere i modificatori di accesso della classe etc...
\item premere finish
\end{itemize}
\end{itemize}
Come noti  Eclipse automaticamente aggiunge il package, gli identificatori etc...

\begin{itemize}
\item \textbf{Running a project in Eclipse}
\begin{itemize}
\item cliccare con il tasto destro sulla classe che si desidera eseguire (\emph{deve contenere il metodo  main})
\item Run As $>$ Java Application
\end{itemize}
\end{itemize}

\begin{itemize}
\item \textbf{Che cosa succede?}
\begin{itemize}
\item se apriamo il workspace notiamo che il nostro progetto contiene varie cartelle: 
\begin{itemize}
\item src: contiene i file sorgenti delle nostre applicazioni (\texttt{.java} files)
\item target: contiene i file che contengono il bytecode (\texttt{.class} files) che sono generati dopo aver eseguito la procedura appena descritta. La compilazione ed esecuzione \`e resa trasparente all'utente
\end{itemize}
\end{itemize}
\end{itemize}

\subsection{Java \`e orientato agli oggetti e staticamente tipizzato}

\subsubsection{Esercizio}
\Esercizio{Deve essere possibile monitorare la velocit\`a la marcia inserita e il ritmo di pedalata di una bicicletta}


\lstinputlisting{Source/eclipse/Esercitazione1/src/main/java/esercizio10/Bike.java}


Il ``Monitoring" di un oggetto \`e eseguito mediante i metodi getters.\\
Command tricks:
\begin{itemize}
\item il comando Control + Space permette di completare automaticamente il testo e fornisce suggerimenti al riguardo
\end{itemize}


\lstinputlisting{Source/eclipse/Esercitazione1/src/main/java/esercizio10/Client.java}



\subsubsection{Esercizio}
\Esercizio{Deve essere possibile incrementare la marcia inserita e il ritmo di pedalata, in tal caso la velocit\`a deve aumentare di conseguenza}

\lstinputlisting{Source/eclipse/Esercitazione1/src/main/java/esercizio11/Bike.java}

\lstinputlisting{Source/eclipse/Esercitazione1/src/main/java/esercizio11/Client.java}


\begin{itemize}
\item \textbf{Quesiti}
\begin{itemize}
\item Qual \`e lo stato dell'oggetto \texttt{bike1} dopo che l'istruzione \texttt{bike1.incrementGear();} \`e eseguita? 
\texttt{gear=2}, \texttt{cadence=0}, \texttt{speed=0}.
\item Qual \`e lo stato dell'oggetto  \texttt{bike1} dopo che l'istruzione \texttt{bike1.changeCadence(10);} \`e eseguita? 
\texttt{gear=2}, \texttt{cadence=10}, \texttt{speed=0}.
\end{itemize}
\end{itemize}

\subsubsection{Esercizio}
\Esercizio{La classe di biciclette considerate ha $6$ marce}

\lstinputlisting{Source/eclipse/Esercitazione1/src/main/java/esercizio12/Bike.java}




\subsection{Variabili e tipi di riferimento}

\subsubsection{Esercizio}
\Esercizio{Analizzare che cosa succede eseguendo il seguente codice}

\lstinputlisting{Source/eclipse/Esercitazione1/src/main/java/esercizio13/Client.java}

Per avere una visualizzazione migliore di quanto accade utilizzeremo il debugger di eclipse. Il debugger vi consente di eseguire passo passo il vostro codice e vi assiste nell'individuazione e nella correzioni di errore in un programma.

\begin{itemize}
\item cliccare con il tasto destro del mouse sulla barra vertical a fianco a \texttt{public static void main}
\item cliccare su \texttt{toggle breakpoint}
\item cliccare con il tasto destro sulla nostra classe (Client.java)
\item cliccare su debug as Java Application
\item se viene chiesto se aprire la perspective di debug rispondere Yes
\end{itemize}
Nella View variables \`e possibile vedere passo passo le variabili sullo stack. Se una variabile \`e di tipo reference \`e possibile esplorare il corrispondente oggetto (e di conseguenza lo heap)

\`E possibile proseguire nell'esecuzione del codice (un passo alla volta) premendo sul pulsante step over (la freccia gialla posta al centro delle le tre in alto a sinistra)\footnote{Un utilizzo pi\`u dettagliato del debugger verr\`a descritto nel corso del laboratorio}.



\subsection{Costruttori}
\subsubsection{Esercizio}
\Esercizio{Modificare la classe bicicletta affinch\`e sia possibile creare una bicicletta con un numero di marce  un dato ritmo di pedalata}

\lstinputlisting{Source/eclipse/Esercitazione1/src/main/java/esercizio14/Bike.java}

\lstinputlisting{Source/eclipse/Esercitazione1/src/main/java/esercizio14/Client.java}


\textbf{Quesiti:}\\
\begin{itemize}
\item Qual \`e lo stato dell'oggetto \texttt{bike1} dopo che l'istruzione   \texttt{bike1=new Bike(3, 2);} \`e eseguita? 
\texttt{gear=3}, \texttt{cadence=2}, \texttt{speed=0}.
\item Qual \`e lo stato dell'oggetto  \texttt{bike2} dopo che l'istruzione  \texttt{Bike bike2=new Bike(1, 2);} \`e eseguita? 
\texttt{gear=1}, \texttt{cadence=2}, \texttt{speed=0}.
\item Qual \`e lo stato dell'oggetto \texttt{bike1} dopo che l'istruzione \texttt{bike1.incrementGear();} \`e eseguita? 
\texttt{gear=3}, \texttt{cadence=2}, \texttt{speed=0}.
\item Qual \`e lo stato dell'oggetto \texttt{bike1} dopo che l'istruzione   \texttt{bike1.changeCadence(10);} \`e eseguita? 
\texttt{gear=3}, \texttt{cadence=10}, \texttt{speed=0}.
\end{itemize}

\subsubsection{Esercizio}
\Esercizio{Analizzare che cosa succede eseguendo il seguente codice}

\lstinputlisting{Source/eclipse/Esercitazione1/src/main/java/esercizio15/Client.java}


\subsubsection{Esercizio}
\Esercizio{Modificare la classe bicicletta affinch\`e sia possibile creare una bicicletta con un dato numero di marce}

\lstinputlisting{Source/eclipse/Esercitazione1/src/main/java/esercizio16/Bike.java}



\subsection{Array}
\subsubsection{Esercizio}
\Esercizio{Creare un array di bike, riempirlo e stampare la pi\`u veloce}

\lstinputlisting{Source/eclipse/Esercitazione1/src/main/java/esercizio17/ArrayOfBikes.java}

\section{Curiosity}
\begin{framed}
Il nome  Java riflette la passione del teams di sviluppatori per il caff\`e. Java \`e un particolare tipo di chicco di caff\`e prodotto nell'isola  Indonesiana  di Java.
\end{framed}


\clearpage

% ---- Bibliography ----




\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{alpha}
\bibliography{Intro}
\nocite{*}


\end{document}

